# PLAN2: 파일/폴더 Flush (현재 구현 기준)

## 목표
- 웹 UI에서 **대상 디렉토리 경로**와 **여러 파일(경로/이름 + 내용)**을 선택하고 시작하면,
  target PC에서 지정된 디렉토리에 동일한 구조로 파일들이 생성되고 내용이 정확히 기록된다.
- 구현 수단은 기존과 동일하게 **HID 키보드 입력 신호(타이핑)**만 사용한다.
- 우선순위는 속도보다 **정확성(완전 동일한 파일 생성/내용 기록/검증)**이다.

## 현재 구현 요약
- UI: [web/files.html](web/files.html)
- 로직: [web/files.js](web/files.js)
- 대상 OS: Windows 전용
- 방식:
   1) 브라우저에서 파일을 `ArrayBuffer`로 읽음
   2) Base64(ASCII)로 변환하여 “타이핑 가능한 문자”만 전송
   3) Target PC에서 PowerShell이 Base64를 디코드하여 `[IO.File]::WriteAllBytes()`로 저장
   4) `Get-FileHash -Algorithm SHA256`로 검증(불일치 시 즉시 실패)
   5) 임시 파일 정리
- 자동화:
   - Win+R → PowerShell 실행은 Macro Characteristic으로 수행(텍스트 채널과 분리)

## 가능 여부(핵심 결론)
- **가능은 하다.** 터미널(또는 셸)을 열고 디렉토리를 생성/이동한 다음 파일을 생성하고 내용을 입력해 저장하면 된다.
- 다만 **OS/셸/에디터 가용성**(Windows에서 `vi` 유무 등)과 **특수문자/인코딩/줄바꿈** 문제 때문에,
  “단순히 vi로 열고 웹에서 받은 내용을 타이핑” 방식만으로는 정확성이 깨질 가능성이 높다.
- 따라서 **(1) 자동 작성 방식(권장) + (2) 검증(해시) + (3) 폴백(에디터 입력)**을 포함한 계획이 필요하다.

## 전제/가정(정확도에 직결)
- 사용자는 target PC를 **정당하게 제어할 권한**이 있고, 자동 타이핑으로 파일을 생성하는 목적이 합법/정상 사용이다.
- 본 PLAN2의 기준 OS는 **Windows** 이다.
   - 필수: PowerShell(기본), `Get-FileHash`(기본)
- 키보드 레이아웃/IME(한영 전환), 자동완성, 터미널 설정(스마트따옴표 등)이 결과에 영향을 주지 않도록 제어해야 한다.

## 사용자 플로우(웹)
1. **Target Directory** 입력
   - 결정: **Windows 절대경로**
   - 제약(현재 UI, 정확성 우선): **영문(ASCII)만 / 공백 불가**
   - 예: `C:\temp\byteflusher_out`
2. 파일 여러 개 추가
   - 결정: **최상위 폴더 하나** 또는 **파일 하나**
     - 폴더 선택 시: 하위 디렉토리 구조를 그대로 target에 생성
     - 파일 선택 시: targetDir 바로 아래에 파일명만 생성
   - 결정(정확성): 파일 내용은 **텍스트로 재인코딩하지 않고 “바이트 그대로” 보존**
3. Start
   - 웹 → 디바이스로 “실행 시나리오(키 입력 시퀀스)”를 전송하고 진행률 표시

## 설계 포인트
### 0) (중요) 소스 구조 분리(1번 기능과 분리)
- 목표: 기존 1번 기능(텍스트 Flush)과 2번 기능(파일 생성/기록)이 서로 영향을 최소화하도록, 웹 소스를 기능 단위로 분리한다.
- 원칙:
   - 공통(BLE 연결/전송/설정/상태표시)은 `core`로 모으고, 기능별 로직은 `features/<feature>` 아래로 둔다.
   - “전송 방법(Chunking/Retry/Flow Control)”은 공통으로 유지하고, 기능별 차이는 “무엇을 전송하느냐(payload 생성)”로만 제한한다.

#### 권장 웹 파일 구조(초안)
#### 현재 웹 파일 구조(구현)
- [index.html](index.html): 랜딩(기능 선택)
- [web/text.html](web/text.html) + [web/text.js](web/text.js): Text Flush
- [web/files.html](web/files.html) + [web/files.js](web/files.js): File/Folder Flush (Windows)
- [web/style.css](web/style.css): 공통 스타일

> 향후 리팩터링으로 `core/` 분리는 가능하지만, 현재는 정확성/검증을 우선하여 단일 파일에 유지한다.

### 1) OS별 전략 분기
- 결정: 본 PLAN2는 **Windows(PowerShell)** 기준으로 구현한다.

### 2) 파일 기록 방식(정확성 우선 권장 순서)
#### A. (권장) PowerShell로 “바이트를 그대로 파일로 씀” + 해시 검증
- 목표: 에디터(vi)에서 사람처럼 타이핑하는 대신, **명령으로 파일을 생성**하고 내용을 투입.
- 단, 단순 `echo`/`>`는 특수문자/줄바꿈/인코딩 문제가 큼.

**Windows PowerShell 권장안(바이트 보존):**
- 파일은 브라우저에서 `ArrayBuffer`로 읽고 Base64로 전송한다.
- target PC에서 PowerShell이 Base64를 `byte[]`로 디코드하고, `[IO.File]::WriteAllBytes()`로 기록한다.
- 이후 `Get-FileHash -Algorithm SHA256`로 해시를 계산해 웹에서 계산한 기대값과 비교한다.

#### B. (권장) Base64로 내용 전송 → target PC에서 디코드 후 저장
- 장점: 키보드로 쳐야 하는 문자가 `A-Za-z0-9+/=` 중심이라 **레이아웃/이스케이프 리스크가 크게 감소**.
- 단점: 길이가 늘어나며, 디코드 도구가 필요.

**Windows 예시(가능한 옵션):**
- PowerShell: `[Convert]::FromBase64String()` + `[IO.File]::WriteAllBytes()`
- (대안) `certutil -decode` (환경에 따라 가능)

**macOS/Linux 예시:**
- `base64 -d` 또는 `python -c`로 디코드

#### C. (폴백) 에디터(vi/nano/notepad)로 열고 타이핑하여 저장
- 장점: 외부 도구 요구가 적음
- 단점: 가장 오류가 많이 나는 방식(특수문자, 탭, 자동 들여쓰기, IME, 저장 실수)
- 폴백으로만 사용하고, 저장 후 반드시 해시 검증을 한다.

### 3) 검증(필수)
- 결정: 각 파일별로 웹에서 **SHA-256** 기대값을 미리 계산하고, target PC에서 파일 생성 후 **해시를 계산**해 일치 여부 확인.
- 결정: **불일치 시 즉시 중단(정확성 최우선)**
- Windows: `Get-FileHash -Algorithm SHA256 <path>`

### 4) 디렉토리/경로 처리
- 입력된 target directory가 없으면 생성한다.
- 파일은 `relativePath` 기준으로 하위 디렉토리를 먼저 생성한다.
- 결정: target directory는 공백이 없으므로 quoting 부담은 낮지만, 안전을 위해 PowerShell에서는 항상 따옴표로 감싼다.

## 실행 시퀀스(개념 단계)
> Windows 기준이며, 정확성 때문에 “PowerShell을 자동으로 열고 실행”까지 포함한다.

### 느린 Target PC(중요): PowerShell 창이 뜨기 전 입력 유실

Target PC 성능이 낮으면 Win+R로 PowerShell을 띄운 직후 첫 입력들이 창이 완전히 준비되기 전에 전송되어,
일부 키 입력이 유실/오입력될 수 있다.

대응(정확성 우선):
- **충분히 큰 대기값**을 기본으로 두고, 환경이 안정적인 경우에만 줄인다.
- 타이밍 파라미터를 분리해 조절한다.
   - `runDialogDelayMs`: Win+R 후 실행창이 뜰 때까지 대기
   - `psLaunchDelayMs`: PowerShell 실행 후 첫 명령을 치기 전까지 대기(가장 중요)
   - `bootstrapDelayMs`: 런처/헬퍼 설치 후 다음 단계로 넘어가기 전 대기

권장 초기값(느린 PC 기준 가이드):
- `psLaunchDelayMs`: 6000~15000ms
- 필요하면 20000ms까지 상향

폴백(추가 안전장치):
- 자동 실행 대신, 사용자가 PowerShell을 미리 열고 커서를 맞춘 뒤 Start하는 “수동 모드”를 제공하면 입력 유실 위험이 크게 줄어든다.

1. 터미널 열기
   - 결정(구현): Macro Characteristic으로 Win+R → `powershell -NoProfile -ExecutionPolicy Bypass` → Enter
   - (정확성 주의) UAC/포커스/키보드 레이아웃에 따라 실패할 수 있으므로, 실행 시작 전 사용자 안내가 필요

2. 대상 디렉토리 생성 및 이동
   - Windows PowerShell 개념: `New-Item -ItemType Directory -Force <dir>` 후 `Set-Location <dir>`

3. 파일별 처리(반복)
   - (a) 하위 디렉토리 생성
   - (b) 파일 내용 기록 (A/B/C 중 선택)
   - (c) 해시 검증 (불일치 시 재시도/중단)

4. 종료/리포트
   - 웹에 파일별 성공/실패, 재시도 횟수, 검증 결과 표시

## 구현 체크리스트(정확성 중심)
- IME/한영 상태 제어(가능하면 시작 시 영어 강제)
- 자동완성/스마트 따옴표/자동 들여쓰기 영향 최소화
- 줄바꿈 정책 통일(LF/CRLF)
- UTF-8 인코딩 통일(Windows PowerShell 기본 인코딩 이슈 주의)
- 결정 반영: 본 기능은 **텍스트 재인코딩을 하지 않고 바이트 단위로 기록**하므로, 인코딩 이슈를 근본적으로 회피한다.
- 파일명/경로에 특수문자 포함 시 안전한 quoting 규칙 정의
- 긴 작업 중 포커스 이탈/팝업 발생 대비(최소한의 UI 개입 가정)

## PowerShell 실행 방식(현재 구현 기준)
> 목적: 키보드 입력 신호만으로도 오류 없이 스크립트를 실행하는 것.

## 현재 구현 선택
- 구현은 “혼합형(짧은 런처 설치 + 단계별 커맨드 + Base64 임시 파일)” 형태다.
   - PowerShell은 `-EncodedCommand`로 최소 런처(`bf_boot_append` / `bf_boot_run`)를 먼저 설치한다.
   - 이후 파일 데이터는 Base64를 임시 파일로 누적 기록 → 공백 제거 후 디코드 → 저장 → 해시 검증 순서로 처리한다.
   - 장점: 입력 라인이 짧고 단순해져 키 씹힘/줄 깨짐 위험을 낮춘다.
   - 단점: 커맨드 횟수가 늘어 포커스 이탈에 더 취약하다.

### 옵션 1) “한 번에 실행하는 1회성 스크립트” (권장 기본안)
- 흐름:
   1) PowerShell 실행
   2) 단일 커맨드 1줄을 타이핑하여 스크립트 실행
- 구현 예(개념): PowerShell의 `-EncodedCommand` 또는 `iex ([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String(...)))` 방식
- 장점:
   - quoting/이스케이프 위험이 가장 낮다(입력 문자열이 Base64 위주)
   - “중간 단계에서 사용자가 잘못 입력”할 확률이 낮다
   - 스크립트 내부에서 파일 생성/검증/중단을 일관되게 처리 가능
- 단점:
   - 입력 길이가 길어질 수 있다(파일 수/크기에 비례)

### 옵션 2) “단계별 커맨드(짧게 여러 번)”
- 흐름:
   1) targetDir 준비
   2) 파일 1개씩 Base64 덩어리 입력 → 디코드 → 저장 → 해시검증
- 장점:
   - 한 번에 입력해야 하는 문자열이 짧다
- 단점:
   - 반복 횟수 증가로 실수 가능성이 올라간다
   - 상태(현재 처리 중 파일/경로/오류 처리)가 분산되어 정확성이 떨어질 수 있다

### 현재 추천
- 정확성 최우선 기준으로 “런처(EncodedCommand) + 단계별 커맨드” 방식을 유지한다.
- 작업이 길어질수록 포커스/팝업 리스크가 커지므로, 딜레이/청크 길이는 보수적으로 시작하고 환경에 맞춰 조정한다.

## 펌웨어(main.cpp) 정책(정확성 보강)
- 결정: Abort(즉시 폐기) 시 버퍼/내부 상태를 리셋하는 기존 동작은 유지한다.
- 결정: **새 sessionId + seq=0으로 새 작업이 시작될 때도 내부 상태(UTF-8/CRLF/한영 모드)를 리셋**하여,
   이전 작업이 중간에 끊겨도 새 작업에 상태가 섞이지 않게 한다.

## 범위(2차 기능에서 포함/제외)
### 포함
- 웹 UI: 디렉토리 지정 + 파일 다중 선택 + 시작
- 디바이스: OS별 터미널 자동화, 디렉토리 생성/이동, 파일 생성/기록
- 파일별 SHA-256 검증 및 실패 처리

- 바이너리 파일(이미지/zip/exe 등) 지원
   - Base64 전송 후 바이트로 복원하므로 종류 제한이 없다.

### 제외(추후)
- 파일 권한/퍼미션/타임스탬프 복원
- OS 자동 감지(정확도 떨어질 수 있어 보류)

## 다음 액션
1. (정확성) 포커스 이탈/팝업에 대한 실전 실패 케이스 수집 및 재시도 UX 개선
2. (정확성) 경로/파일명 특수문자(공백/한글/괄호) 케이스 테스트 확장
3. (개선) `-EncodedCommand` 기반 “단일 명령” 모드 추가 검토(타이핑 횟수 감소)
