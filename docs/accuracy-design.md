# 정확성(Accuracy) 우선 설계/제약 (ByteFlusher)

ByteFlusher는 타이핑 속도보다 **정확성(누락/중복/깨짐 방지)**을 우선합니다. 이 문서는 “왜 이렇게 설계했는지”, “어떤 제약이 있는지”, “정확도를 위해 무엇을 조절해야 하는지”를 Q&A 형태로 정리합니다.

## Q. 왜 USB HID(키보드) 방식이면서도 정확성이 어렵나요?
A. USB HID 키보드 입력은 OS/앱 관점에서 “사람이 누르는 키”와 동일하게 처리됩니다. 따라서 아래 요소가 정확성을 깨뜨릴 수 있습니다.

- 포커스 이동(알림/팝업/UAC/자동완성/다른 창 클릭)
- IME(한/영 전환, 조합 중 상태)와 앱 내부 입력기 동작 차이
- 앱의 자동 기능(자동 들여쓰기/자동 괄호/자동 완성/자동 포맷)
- 키 입력이 너무 빠를 때 발생하는 누락(특히 콘솔/원격환경/가상화)

정확성은 “전송이 정확함” + “타깃 입력기가 정확히 받음” 두 축이 모두 만족되어야 합니다.

## Q. ByteFlusher는 정확성을 위해 무엇을 하나요?
A. 크게 3개입니다.

### 1) 중복 방지(프로토콜)
- BLE로 텍스트를 청크로 나눠 보내되, 끊김/재시도 시 같은 청크가 다시 전송될 수 있습니다.
- 이를 대비해 청크에 `sessionId/seq`를 포함하고, **이미 처리한 청크는 무시**해 중복 타이핑을 막습니다.

### 2) Flow Control(버퍼 기반)
- 장치(보드) RX 버퍼 여유를 상태로 알려주고, 웹이 여유가 있을 때만 전송합니다.
- 목적: 버퍼를 과도하게 밀어넣지 않아 **Pause/Stop이 진짜 즉시** 멈추도록 하고, 장치가 안정적으로 소비(타이핑)하도록 합니다.

### 3) 타이핑 타이밍(안정화)
- 문자 입력 후 대기(`typingDelayMs`), 키 눌림 유지(`keyPressDelayMs`), 한/영 전환 후 대기(`modeSwitchDelayMs`)를 둡니다.
- 기본값은 빠르기보다 안정성에 맞춘 값입니다.

## Q. 정확성 관점에서 “중요한 제약”은 뭐가 있나요?
A. 아래는 설계상/물리상 쉽게 사라지지 않는 제약입니다.

- **포커스는 절대 자동으로 보장할 수 없습니다.** 시작 전 커서 위치를 확인하고, 실행 중에는 포커스를 빼앗기지 않게 해야 합니다.
- **IME 동기화는 100% 보장 불가**입니다. 한/영 전환키는 환경마다 다르고, 앱/OS 상태에 따라 토글 결과가 달라질 수 있습니다.
- **앱 자동기능은 오입력/변형을 만들 수 있습니다.** 정확성 테스트는 메모장 같은 단순 에디터에서 먼저 해야 합니다.
- **길이가 길수록 실패 확률이 누적**됩니다. 긴 작업은 체크포인트(중간 Stop/재시작) 전략이 유리할 수 있습니다.

## Q. 정확성 우선 권장 세팅은?
A. 우선순위는 다음입니다.

1) 타깃 앱을 단순화(메모장/단순 텍스트) → 성공 후 IDE/터미널로 이동
2) 키 입력 딜레이를 늘려 안정화
3) IME 토글/대기값을 늘려 모드 전환 안정화

권장(시작점):
- `typingDelayMs`: 30~80ms (환경이 느리면 120ms까지)
- `keyPressDelayMs`: 10~30ms
- `modeSwitchDelayMs`: 100~400ms (IME가 불안정하면 800ms까지)

## Q. “정확성 테스트”는 어떻게 하면 좋나요?
A. 실패 원인을 빠르게 분리하려면, 다음 순서가 좋습니다.

- (1) **짧은 ASCII 텍스트** (영문+숫자+기호) → 누락 여부 확인
- (2) 줄바꿈/탭 포함 → IDE/터미널에서 영향 확인
- (3) 한글(IME) 포함 → 한/영 전환/조합 깨짐 확인
- (4) 긴 텍스트(수천~수만 chars) → 누적 안정성 확인

각 단계에서 실패하면 다음 단계로 넘어가지 말고 해당 축(포커스/타이밍/IME/앱자동기능)을 먼저 해결합니다.
